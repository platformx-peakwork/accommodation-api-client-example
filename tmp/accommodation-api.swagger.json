{
  "swagger": "2.0",
  "info": {
    "title": "accommodation-api.proto",
    "description": "The Peakwork Accommodation API is used by accommodation suppliers like bed banks or hotel chains to provide their\naccommodation portfolio to the Peakwork network for distribution to partner companies like tour operators.\n\nIt is composed of two services:\n- BaseDataService: methods to maintain basic entities like accommodations or rooms, shared among all distribution\n  partners of a supplier.\n- OfferDataService: methods to update offers, i.e. the price and availability information about the accommodation\n  portfolio of a supplier. Offers can be shared among distribution partners of a supplier or specific for single\n  partners.",
    "version": "version not set"
  },
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/basedata/accommodations": {
      "put": {
        "summary": "Creates a new accommodation entity for the supplier.\nIf an accommodation with the same identity already exists, its content is replaced by the new data.",
        "description": "See Accommodation for further information about the accommodation entity and how it is identified.",
        "operationId": "UpsertAccommodation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Accommodation entity including base data belonging to the request. This field contains the data to be sent,\ne.g. for updating purposes.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/basedataAccommodation"
            }
          }
        ],
        "tags": [
          "BaseDataService"
        ]
      }
    },
    "/basedata/boards": {
      "put": {
        "summary": "Creates a new board entity for the supplier.\nIf a board with the same identity already exists, its content is replaced by the new data.",
        "description": "See Board for further information about the board entity and how it is identified.",
        "operationId": "UpsertBoard",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Board entity including base data belonging to the request. This field contains the data to be sent,\ne.g. for updating purposes.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/basedataBoard"
            }
          }
        ],
        "tags": [
          "BaseDataService"
        ]
      }
    },
    "/basedata/rates": {
      "put": {
        "summary": "Creates a new rate entity for the supplier.\nIf a rate with the same identity already exists, its content is replaced by the new data.",
        "description": "See Rate for further information about the rate entity and how it is identified.",
        "operationId": "UpsertRate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Rate entity including base data belonging to the request. This field contains the data to be sent,\ne.g. for updating purposes.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/basedataRate"
            }
          }
        ],
        "tags": [
          "BaseDataService"
        ]
      }
    },
    "/basedata/rooms": {
      "put": {
        "summary": "Creates a new room entity for the supplier.\nIf a room with the same identity already exists, its content is replaced by the new data.",
        "description": "See Room for further information about the room entity and how it is identified.",
        "operationId": "UpsertRoom",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Room entity including base data belonging to the request. This field contains the data to be sent,\ne.g. for updating purposes.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/basedataRoom"
            }
          }
        ],
        "tags": [
          "BaseDataService"
        ]
      }
    },
    "/offerdata/accommodation_offers": {
      "put": {
        "summary": "Creates offer data for a given combination of:\n- accommodation\n- rate\nfor a supplier.\nIf offer information for the given accommodation/rate combination already exists, all information is replaced by\nthe new data. Offer data for the same accommodation but a different rate is not replaced. Analogously, offer data\nfor the same rate but a different accommodation is also not replaced.\nThis implicitly removes all previously existing offer data of the accommodation/rate combination, that are not\ndelivered again in that call.",
        "description": "UpsertAccommodationOfferData is the highest level on which to update offer data. It is meant for for the following\nscenarios:\n- a supplier wants to run an initial import of the portfolio offer data\n- a supplier's system produces updates of price information on an accommodation level\n- a supplier wants to reset the offer data of an accommodation\n- a supplier wants to remove offer data of an accommodation implicitly by explicitly delivering all available\n  offer data\n\nUpsertAccommodationOfferData is not intended for the following scenarios:\n- a single price/allotment has changed\n- a supplier's system produces updates of price information on a room or board level for an accommodation\n- a supplier's system produces updates of price information on arrival date or length of stay level\n\nSee UpsertGroupOfferData and UpsertSingleOfferData for information on how to update offer data on lower levels\nwithout replacing all offer data for an accommodation/rate combination.",
        "operationId": "UpsertAccommodationOfferData",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "mandatory - The offer data for exactly one accommodation and one rate, that is being delivered",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/offerdataAccommodation_OfferData"
            }
          }
        ],
        "tags": [
          "OfferDataService"
        ]
      }
    },
    "/offerdata/groupoffers": {
      "put": {
        "summary": "Remark: This call is not yet fully supported!",
        "description": "Creates offer data for a given combination of:\n- accommodation\n- rate\n- room\n- board\nfor a supplier.\nIf offer information for the given accommodation/rate/room/board combination already exists, all information is\nreplaced by the new data. Offer data for the same combination but e.g. for a different room or board is not\nreplaced.\nThis implicitly removes all previously existing offer data of the accommodation/rate/room/board combination,\nthat are not delivered again in the call.\n\nUpsertGroupOfferData is meant for for the following scenarios:\n- a supplier wants to run an initial import of the portfolio offer data\n- a supplier's system produces updates of price information on a room or board level for an accommodation\n- a supplier wants to reset the offer data of a room or board for an accommodation\n- a supplier wants to remove offer data of a room or board implicitly by explicitly delivering all available\n  offer data for that room or board\n\nUpsertGroupOfferData is not intended for the following scenarios:\n- a single price/allotment has changed\n- a supplier's system produces updates of price information on arrival date or length of stay level\n\nSee UpsertAccommodationOfferData and UpsertSingleOfferData for information on how to update offer data on\ndifferent levels with different replacement mechanisms.",
        "operationId": "UpsertGroupOfferData",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "mandatory - The offer data for exactly one a group, i.e. a combination of an accommodation, rate, room and board,\nthat are being delivered",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1GroupOfferDataDeliveryPayload"
            }
          }
        ],
        "tags": [
          "OfferDataService"
        ]
      }
    },
    "/offerdata/singleoffer": {
      "put": {
        "summary": "Remark: This call is not yet fully supported!",
        "description": "Creates offer data for a given combination of:\n- accommodation\n- rate\n- room\n- board\n- arrival date\n- length of stay\nfor a supplier.\nIf offer information for the given accommodation/rate/room/board/arrival-date/length-of-stay combination already\nexists, all information is replaced by the new data. Offer data for the same combination but e.g. for a different\narrival date or length of stay is not replaced.\n\nUpsertSingleOfferData is meant for for the following scenarios:\n- a single price/allotment has changed\n- a supplier's system produces updates of price information on arrival date or length of stay level\n- a booking system detected, that the cached price/availability does not match the live data\n\nUpsertSingleOfferData is not intended for the following scenarios:\n- a supplier wants to run an initial import of the portfolio offer data\n- a supplier wants to remove offer data\n\nSee UpsertAccommodationOfferData and UpsertGroupOfferData for information on how to update offer data on\nhigher levels with different replacement mechanisms.",
        "operationId": "UpsertSingleOfferData",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "mandatory - The offer data for a single offer, i.e. a combination of an accommodation, rate, room, board, arrival\ndate and length of stay, that are being delivered",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1SingleOfferDataDeliveryPayload"
            }
          }
        ],
        "tags": [
          "OfferDataService"
        ]
      }
    }
  },
  "definitions": {
    "basedataAccommodation": {
      "type": "object",
      "properties": {
        "supplier_accommodation_id": {
          "type": "string",
          "description": "mandatory - Identifies an accommodation within the scope of one supplier, i.e. it must be unique per supplier. A\nsupplier can choose the identifier arbitrarily but must make sure, that the identifier is consistent, i.e. the same\naccommodation from the supplier's system has the same supplier_accommodation_id, whenever it is referenced in the\nAccommodation API. This is especially important, when updating accommodation data. Data of an accommodation with\nthe same identifier will be replaced, since they are considered to reference the same accommodation entity."
        },
        "name": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "mandatory - The names of the accommodation in multiple languages as a map. At least one name must be given.\n- key (string): Language code in the format language_country with language being a ISO 639-1 language code and country\nbeing a ISO 3166-1 Alpha-2 country code (e.g. \"en_GB\", \"en_US\", \"de_DE\" or \"de_CH\")\n- value (string): the name of the accommodation in the corresponding language"
        },
        "address": {
          "$ref": "#/definitions/basedataAddress",
          "title": "mandatory - Address of the accommodation"
        },
        "coordinates": {
          "$ref": "#/definitions/basedataCoordinates",
          "title": "optional - Geographical coordinates of the accommodation"
        },
        "arrival_airports": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "optional - List of airports, that can be used for arrival at the accommodation. Each entry denotes an airport in\nIATA code format."
        },
        "star_rating": {
          "type": "number",
          "format": "double",
          "title": "mandatory - Accommodation rating in form of stars. Possible values from 0-7 in steps of 0.5:\n[ 0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6,5, 7 ]"
        },
        "booking_payload": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "optional - Meta information used for booking purposes. These are arbitrary key-value pairs, that are transported\nback to the supplier, when a booking of an offer for this rate is made, in order for the supplier to be able to\ncorrectly book the offer in its system."
        }
      },
      "description": "Represents an accommodation, e.g. a hotel, within a supplier's accommodation portfolio. This entity contains meta\ninformation about the accommodation, e.g. to give out the the end customer."
    },
    "basedataAddress": {
      "type": "object",
      "properties": {
        "city": {
          "type": "string",
          "description": "mandatory - City of the address."
        },
        "street": {
          "type": "string",
          "description": "mandatory - Street of the address."
        },
        "zip_code": {
          "type": "string",
          "description": "optional - Zip code of the address."
        },
        "country": {
          "type": "string",
          "title": "mandatory - Country of the address"
        }
      },
      "description": "Represents a world location in form of an address."
    },
    "basedataBoard": {
      "type": "object",
      "properties": {
        "board_identifier": {
          "type": "string",
          "description": "mandatory - Identifies a board within the scope of one supplier, i.e. it must be unique per supplier. A supplier\ncan choose the identifier arbitrarily but must make sure, that the identifier is consistent, i.e. the same\nboard from the supplier's system has the same board_identifier, whenever it is referenced in the Accommodation API.\n This is especially important, when updating rate data. Data of a rate with the same identifier will be replaced,\nsince they are considered to reference the same rate entity."
        },
        "name": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "mandatory - The names of the board in multiple languages as a map. At least one name must be given.\n- key (string): Language code in the format language_country with language being a ISO 639-1 language code and country\nbeing a ISO 3166-1 Alpha-2 country code (e.g. \"en_GB\", \"en_US\", \"de_DE\" or \"de_CH\")\n- value (string): the name of the board in the corresponding language"
        },
        "global_types": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1GlobalType"
          },
          "description": "mandatory - List of DRV GlobalTypes giving meta information about the board."
        },
        "booking_payload": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "optional - Meta information used for booking purposes. These are arbitrary key-value pairs, that are transported\nback to the supplier, when a booking of an offer for this board is made, in order for the supplier to be able to\ncorrectly book the offer in its system."
        }
      },
      "description": "Represents a board (or more precisely: a board type), also called meal of a supplier's accommodation portfolio and\ncontains the meta information of that board, e.g. to give out the the end customer.\n\nA board is a global object used by a supplier and not directly connected to an accommodation, room or rate. The\nconnection between boards and other base entities is indirect and comes from offers. Offers connect boards with other\nentities like accommodations. This means, that a board can for example be used only in a single accommodation, if the\nrelevant meta information of said board is specific to an accommodation, or it can be used in multiple\naccommodations, if the meta information is independent of the accommodation (e.g. \"a standard bed and breakfast\").\nA supplier may therefore categorize boards by its own criteria."
    },
    "basedataCoordinates": {
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number",
          "format": "double",
          "title": "mandatory - Latitude of the coordinates, eg.: 25.799891"
        },
        "longitude": {
          "type": "number",
          "format": "double",
          "title": "mandatory - Longitude of the coordinates, eg.: -102.744140"
        }
      },
      "description": "Geographical coordinates in form of latitude and longitude used to express the exact location of an accommodation."
    },
    "basedataOccupancy": {
      "type": "object",
      "properties": {
        "min_pax": {
          "type": "integer",
          "format": "int32",
          "description": "optional - default: 1 - Minimum number of persons allowed in total. Must be greater than or equal to 1."
        },
        "max_pax": {
          "type": "integer",
          "format": "int32",
          "description": "mandatory - Maximum number of persons allowed in total."
        },
        "min_adults": {
          "type": "integer",
          "format": "int32",
          "description": "optional - default: 1 - Minimum number of adults allowed. Must be greater than or equal to 1."
        },
        "max_adults": {
          "type": "integer",
          "format": "int32",
          "description": "optional - Maximum number of adults allowed."
        },
        "min_children": {
          "type": "integer",
          "format": "int32",
          "description": "optional - default: 0 - Minimum number of children allowed."
        },
        "max_children": {
          "type": "integer",
          "format": "int32",
          "description": "optional - default: 0 - Maximum number of children allowed."
        },
        "min_child_age": {
          "type": "integer",
          "format": "int32",
          "description": "optional - default: 2 - Minimum age in years, where a person is considered a child (inclusive). Persons younger\nthan this age are considered infants. Persons older than this age are considered either children or adults,\ndepending on max_child_age."
        },
        "max_child_age": {
          "type": "integer",
          "format": "int32",
          "description": "optional - default: 17 - Maximum age in years, where a person is considered a child (inclusive). Persons older than\nthis age are considered adults. Persons younger than this age are considered either children or infants, depending\non min_child_age."
        },
        "max_infants": {
          "type": "integer",
          "format": "int32",
          "description": "optional - Maximum number of infants allowed. If not given, no maximum restrictions towards infants apply."
        },
        "infants_apply_to_occupancy": {
          "type": "boolean",
          "format": "boolean",
          "description": "optional - default: false - Defines whether or not infants are counted towards the total pax restrictions (min_pax\nand max_pax). If true, infants count towards the total pax count, i.e. the total pax count including infants\ncannot exceed the max_pax restrictions and the min_pax restriction can be met by infants. If false, infants do not\ncount towards the total pax count, i.e. the total pax count including infants may exceed max_pax and infants do not\ncount towards min_pax."
        }
      },
      "description": "Represents an occupancy, i.e. a set of possible combinations of persons (pax) in a travel. An occupancy distinguishes\nbetween three types of persons: adults, children and infants. To which type a person is assigned is determined by the\npersons's age (see min_child_age and max_child_age).\nThe set of possible combinations of persons allowed by an occupancy is determined by a set of restrictions on the\ncounts of persons per person type as well as the overall person count. If a combination of persons meets all of these\nrestrictions, this combination is included in the set of possible person combinations, that the occupancy defines."
    },
    "basedataRate": {
      "type": "object",
      "properties": {
        "rate_identifier": {
          "type": "string",
          "description": "mandatory - Identifies a rate within the scope of one supplier, i.e. it must be unique per supplier. A supplier\ncan choose the identifier arbitrarily but must make sure, that the identifier is consistent, i.e. the same rate\nfrom the supplier's system has the same rate_identifier, whenever it is referenced in the Accommodation API. This\nis especially important, when updating rate data. Data of a rate with the same identifier will be replaced, since\nthey are considered to reference the same rate entity."
        },
        "global_types": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1GlobalType"
          },
          "title": "optional - List of DRV GlobalTypes giving meta information about the rate (i.e. all offers for the rate)"
        },
        "booking_payload": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "optional - Meta information used for booking purposes. These are arbitrary key-value pairs, that are transported\nback to the supplier, when a booking of an offer for this rate is made, in order for the supplier to be able to\ncorrectly book the offer in its system."
        },
        "refundable": {
          "type": "boolean",
          "format": "boolean",
          "description": "mandatory - Denotes, whether the rate is refundable (true) or not (false)."
        },
        "target_companies": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/basedataTargetCompanyType"
          },
          "description": "optional - List of company types, that the rate is valid for. This is an indicator for the distribution partners of\nto which type of company (B2B) they are allowed to resell the offers to. If not given, no restriction is applied."
        },
        "target_country": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "optional - List of countries, that the rate is valid for. This is an indicator for the distribution partners of\nwhich countries they are allowed to sell the offers in. Countries are given as ISO 3166-1 Alpha-2 code. If not\ngiven, no country restriction is applied."
        }
      },
      "description": "Represents a rate (or more precisely: a rate type) of a supplier's accommodation portfolio. A rate has two purposes:\n- Distinguishing multiple different prices for the same travel (i.e. accommodation, room, board, arrival date, LOS\n  combination). There might be multiple offers for the same travel, e.g. a non refundable and a refundable price.\n  This can be done by creating multiple offers with the same accommodation, room, board, arrival date, LOS\n  combination but different rates.\n- Transporting meta information about an offer, e.g. for booking purposes or for displaying to the customer.\n\nA rate can be used for multiple offers. It has no direct connection to other base data entities. Therefore, a rate\ncan for example be used in offers of only a single accommodation or even for multiple different accommodations.\nThe supplier is free on how to distinguish rates from each other."
    },
    "basedataRoom": {
      "type": "object",
      "properties": {
        "room_identifier": {
          "type": "string",
          "description": "mandatory - Identifies a room within the scope of one supplier, i.e. it must be unique per supplier. A supplier\ncan choose the identifier arbitrarily but must make sure, that the identifier is consistent, i.e. the same\nroom from the supplier's system has the same room_identifier, whenever it is referenced in the Accommodation API.\nThis is especially important, when updating rate data. Data of a rate with the same identifier will be replaced,\nsince they are considered to reference the same rate entity."
        },
        "name": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "mandatory - The names of the room in multiple languages as a map. At least one name must be given.\n- key (string): Language code in the format language_country with language being a ISO 639-1 language code and country\nbeing a ISO 3166-1 Alpha-2 country code (e.g. \"en_GB\", \"en_US\", \"de_DE\" or \"de_CH\")\n- value (string): the name of the room in the corresponding language"
        },
        "global_types": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1GlobalType"
          },
          "description": "mandatory - List of DRV GlobalTypes giving meta information about the room."
        },
        "booking_payload": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "optional - Meta information used for booking purposes. These are arbitrary key-value pairs, that are transported\nback to the supplier, when a booking of an offer for this room is made, in order for the supplier to be able to\ncorrectly book the offer in its system."
        },
        "occupancy": {
          "$ref": "#/definitions/basedataOccupancy",
          "description": "mandatory - Defines the occupancy of the room, i.e. which constellations of persons are possible (e.g. number of\nadults, children, infants).\n\nAn occupancy allows for multiple constellations of persons. But since an occupancy is\nusing count ranges of different person types to build a cross product of different counts of person types (see\nOccupancy), it is not possible to express every theoretically possible set of person constellations with one\noccupancy.\nExample: only the following constellations are allowed: 1A+0C, 2A+1C =\u003e this constellation is not possible.\nSince a room only allows one possible occupancy, such a case of non expressible constellations must be expressed\nwith multiple different rooms, in the exemplary case: 2 rooms, with 1 occupancy each: 1 with 1A+0C, 1 with 2A+1C."
        }
      },
      "description": "Represents a room (or more precisely: a room type) of a supplier's accommodation portfolio and contains the meta\ninformation of that room, e.g. to give out the the end customer.\n\nA room entity does not necessarily correspond to an actual physical room. It is rather a category of physical rooms\ndetermined by the supplier. Therefore, a room is a global object used by a supplier and not directly connected to an\naccommodation, board or rate. The connection between rooms and other base entities is indirect and comes from offers.\nOffers connect rooms with other entities like accommodations. That means, that for example a room is used only\nin a single accommodation, if the relevant meta information of said room is specific to an accommodation, or it can\nbe used in multiple accommodations, if the meta information is independent of the accommodation (e.g. \"a standard\ndouble room\"). A supplier may therefore categorize rooms by its own criteria."
    },
    "basedataTargetCompanyType": {
      "type": "string",
      "enum": [
        "TOUROP",
        "METASEARCHER",
        "OTA"
      ],
      "default": "TOUROP",
      "description": "- TOUROP: A company acting as a tour operator.\n - METASEARCHER: A company acting as a meta searcher.\n - OTA: A company acting as an online travel agency.",
      "title": "Enumeration of possible company types"
    },
    "offerdataAccommodation_OfferData": {
      "type": "object",
      "properties": {
        "accommodation_identifier": {
          "type": "string",
          "description": "mandatory - Identifier for the accommodation used by the supplier. This identifier references an accommodation\nentity (supplierAccommodationId) from the BaseDataService. See supplierAccommodationId of Accommodation.\nThe offer information of this payload is valid for the referenced accommodation only."
        },
        "rate_identifier": {
          "type": "string",
          "description": "mandatory - Identifier for the rate used by the supplier. This identifier references a rate\nentity (rateIdentifier) from the BaseDataService. See rateIdentifier of Rate.\nThe offer information of this payload is valid for the referenced rate only."
        },
        "split_identifier": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "optional - Split identifier used to split deliveries of offer data for an accommodation and rate further down\nfor technical reasons. Currently not implemented."
        },
        "currency": {
          "type": "string",
          "description": "mandatory - Denotes the currency of the offer prices in the given message. All prices in a single message, e.g. for\ndifferent rooms, boards or arrival dates, have the same currency. The currency is given as code in ISO 4217\nstandard."
        },
        "rooms": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/offerdataRoom_OfferData"
          },
          "description": "mandatory - List of offer data grouped by rooms. rooms contains the offer data information for the message, i.e.\nthe accommodation and rate combination. On this level, the offer data is grouped by rooms (see Room in\nBaseDataService). Each Room_OfferData element will contain all offer data for a single room (in the given\naccommodation and rate key combination)."
        },
        "price_sets": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/offerdataPriceSet"
          },
          "description": "mandatory - Map of all PriceSets used in this message. The price sets are referenced by the data in the various\nRoomOfferData elements via a unique numeric key (uint32). This key is bound to a specific message and can be\narbitrarily chosen. This means a key for a price set in one message can be different for the same price set in a\ndifferent message. It does not serve as a permanent identifier of a price set.\n\nA price set can be referenced multiple times in a single RoomOfferData entity or even in multiple different\nRoomOfferData entities in order to reuse the pricing structure in it. The purpose is to optimize the data size by\nnot duplicating the same price data multiple times (e.g. for the same price on consecutive arrival dates or on\nconsecutive days of the stay).\n\nSee PriceSet for more details."
        }
      },
      "description": "Contains offer data for exactly one combination of an accommodation and a rate.\n\nKeys: accommodation_identifier, rate_identifier(, split_identifier)\nValues: currency, rooms, price_sets\n\nOffer data information is given in rooms (Room_OfferData). The prices in rooms may reference data in price_sets.\nprice_sets is to be used as a lookup table for data in Room_OfferData and is intended for reuse within a\nRoom_OfferData and across different Room_OfferData elements for data size optimization."
    },
    "offerdataAgeRange": {
      "type": "object",
      "properties": {
        "min_age": {
          "type": "integer",
          "format": "int32",
          "description": "optional - default: 1 - The lower bound (closed) of the given age range."
        },
        "max_age": {
          "type": "integer",
          "format": "int32",
          "description": "optional - default: 255 - The upper bound (closed) of the given age range."
        }
      },
      "description": "Represents an age range, i.e. an age of a person between a minimum and maximum age. The range is closed, i.e. both\nvalues are inclusive. Used e.g. in a PersonFilter to indicate a certain set of persons with certain age constraints."
    },
    "offerdataBoard_OfferData": {
      "type": "object",
      "properties": {
        "board_identifier": {
          "type": "string",
          "description": "mandatory - Identifier for the board used by the supplier. This identifier references a board\nentity (boardIdentifier) from the BaseDataService. See boardIdentifier of Board.\nThe offer information of this message is valid for the referenced board only."
        },
        "offer_groups": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/offerdataOfferGroup"
          },
          "description": "mandatory - A list of offer groups. Each offer group contains multiple arrival dates and LOSs, to which the same\npricing structure applies, as well as the price information itself (in form of references to the price_sets).\nMultiple offer groups can be given to represent different arrival date and LOS combinations with different pricing\nstructures.\n\nSee OfferGroup for more details."
        }
      },
      "description": "Contains offer data associated with one board. The offer data is only valid for the board given by its\nboard_identifier. A Board_OfferData entity is to be used in a certain entity (e.g. Room_OfferData) to specify the\ncontext of the offer data even further.\n\nKeys: board_identifier\nValues: offer_groups"
    },
    "offerdataDateLosGroup": {
      "type": "object",
      "properties": {
        "arrival_dates": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/typeDate"
          },
          "title": "mandatory - List of arrival dates with which to build the cross product of arrival date and LOS combinations"
        },
        "loses": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int64"
          },
          "title": "mandatory - List of LOSs with which to build the cross product of arrival date and LOS combinations"
        }
      },
      "description": "Identifies a certain set of arrival date and LOS combinations. Can be used to assign an offer value to multiple\narrival date and LOS combinations (see OfferGroup).\n\nThe possible combinations of arrival date and LOS is the cross product of all arrival dates and LOSs given in the\nDateLosGroup. Example:\n- arrival_dates: 01-01-1970, 02-01-1970\n- loses: 1,2,5\n- resulting arrival date and LOS combinations:\n  - 01-01-1970+1, 01-01-1970+2, 01-01-1970+5\n  - 02-01-1970+1, 02-01-1970+2, 02-01-1970+5"
    },
    "offerdataOfferGroup": {
      "type": "object",
      "properties": {
        "date_los_groups": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/offerdataDateLosGroup"
          },
          "title": "mandatory - A list of arrival date and LOS combinations, that the offer value is valid for"
        },
        "offer": {
          "$ref": "#/definitions/offerdataOfferValue",
          "description": "mandatory - The offer value (including prices), that is valid for the given arrival date and LOS combinations."
        }
      },
      "description": "An OfferGroup represents a group of arrival date and LOS combinations, which all have the same pricing structure, and\nit contains the pricing structure for those combinations.\n\nThe list of DateLosGroup elements groups all arrival date and LOS combinations and the OfferValue element informs\nabout the pricing structure, that is valid for all given arrival date and LOS combinations.\nThis grouping mechanism is used to reuse pricing structures in order to optimize the data size of the messages.\nExample use cases for grouping arrival date and los combinations with the same pricing structure together are:\n- The final price of a travel is the same independent from arrival dates\n- The price of a travel depends on actual days of the stay and not on the total length of the stay. Example: the\n  price of a travel for the first day is X, for the second day is Y and for the third day is Z. Then the pricing\n  structure \"[X],[Y],[Z]\" (see OfferValue) is valid for the LOSs 1 to 3 (aka no matter if the traveller stays 1, 2\n  or 3 days, the first day of the stay always costs X (LOS 1-3), the second Y (LOS 2-3) and the third Z (LOS 3)).\n- The pricing structure repeats every week/month/...\n\nSee DateLosGroup and OfferValue for more details."
    },
    "offerdataOfferValue": {
      "type": "object",
      "properties": {
        "object_price": {
          "type": "number",
          "format": "double",
          "description": "optional - Holds a single final price for the offer. One of object_price or price_set_keys must be used.\n\nIt is the easiest form of an offer price. Example: if the object_price is 50 for a given combination of\naccommodation, rate, room, board, arrival date and LOS and the currency is set to EUR, that exact offer costs 50â‚¬\nand no further price calculation is required."
        },
        "price_set_keys": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int64"
          },
          "description": "optional - Used to represent a complex pricing structure using daily and person specific prices.\nOne of price_set_keys or object_price must be used.\n\nComplex prices are given as a list of references to PriceSet entities (see PriceSet). The context of an OfferValue\nalways contains a map of PriceSet objects (e.g. see Accommodation_OfferData). Each PriceSet in the map has a unique\nkey. This key is used to reference a price set in the price_set_keys list. Each entry references a price set.\n\nMultiple price sets can be referenced in order to represent daily prices. Each entry in the list represents the\nprice for a single day of a stay, whereby a price itself is again a complex price structure to allow person prices\n(see PriceSet). The position of a price set in the list denotes which day of the stay a price is valid for. The\nfirst entry in the list denotes a base price, that is applied to the whole travel. The following entries denote the\nprice for each consecutive day of the stay, starting with the first.\nPrice sets can also be referenced multiple times. Example:\n- Position 0: PriceSet A -\u003e Base price\n- Position 1: PriceSet B -\u003e Day 1\n- Position 2: PriceSet B -\u003e Day 2\n- Position 3: PriceSet C -\u003e Day 3\n- Position 4: PriceSet D -\u003e Day 4\n\nIn order to calculate the final price for a stay, the length of stay has to be considered. Given a length of stay\nof x, the price sets from 0 to x have to be summed up, e.g. for LOS 3 sum up positions 0,1,2,3 of the list\n(PriceSet A + 2*PriceSet B + PriceSet C).\nThis logic allows for an OfferValue to be valid for multiple different lengths of stay. E.g. given the same\nOfferValue for LOSs 1-5, you can calculate 5 different offers (LOSs 1,2,3,4,5) using this single OfferValue object\nand summing up the price sets up to different lengths of the list.\n\nSee PriceSet for how to calculate the price of a single price set."
        },
        "global_types": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1GlobalType"
          },
          "title": "optional - List of DRV GlobalTypes marking meta information about an offer"
        }
      },
      "description": "Representation of the \"value\" of an offer. The value of an offer informs about the final price (and meta information)\nof a travel with given criteria. I.e. given a combination of accommodation, rate, room, board, arrival date and LOS\nthere is exactly one OfferValue matching the criteria. From this OfferValue, that final price of the travel (offer)\ncan be calculated.\n\nThere are multiple ways to structure the price of an offer: either as a single final object price (object_price) or\nas a complex pricing structure, that allows to set daily prices as well as person specific prices (price_set_keys).\n\nIt is not possible to use both \"object_price\" and \"price_set_keys\" at the same time, but it is mandatory to use one\nof them."
    },
    "offerdataPaxCountRange": {
      "type": "object",
      "properties": {
        "min_count": {
          "type": "integer",
          "format": "int32",
          "description": "optional - default: 1 - The lower bound (closed) of the given pax count range."
        },
        "max_count": {
          "type": "integer",
          "format": "int32",
          "description": "optional - default: 15 - The upper bound (closed) of the given pax count range."
        }
      },
      "description": "Represents a pax count range, i.e. a pax count of a person between a minimum and maximum pax count. A Pax count\ndenotes the position of a person in a travel (possibly within certain age ranges).\nExample: pax count = 3 =\u003e \"The third person in the given age range\".\n\nThe range is closed, i.e. both values are inclusive. Used e.g. in a PersonFilter to indicate a certain set of persons\nwith certain pax count constraints."
    },
    "offerdataPersonFilter": {
      "type": "object",
      "properties": {
        "age_ranges": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/offerdataAgeRange"
          },
          "description": "optional - A list of age ranges. The PersonFilter applies to a person, if the person is in at least one of the\ngiven age ranges and the pax_count_range matches. If not given, the PersonFilter is valid for all ages."
        },
        "pax_count_range": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/offerdataPaxCountRange"
          },
          "description": "optional - A list of pax count ranges. A Pax count denotes the position of a person within the age ranges given in\nage_ranges, e.g. pax count = 3 =\u003e \"The third person in the given age range\". The PersonFilter applies to a person,\nif the pax count of the person in the given age ranges is within at least one of the given PaxCountRanges.\nIf not given, the PersonFilter is valid for all pax counts."
        }
      },
      "description": "Represents a set of persons by filtering persons by age ranges and pax count. It is used to to specify which\nperson(s) a price is applicable for."
    },
    "offerdataPersonPrice": {
      "type": "object",
      "properties": {
        "person_price": {
          "type": "number",
          "format": "double",
          "description": "optional - default: 0 - The price, that applies to the set of persons given by the person filters."
        },
        "person_filters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/offerdataPersonFilter"
          },
          "description": "optional - List of person filters, which constitutes the set of persons, that the given price is applied to. The\nPersonPrice applies to a given person, if at least 1 of the PersonFilter entries applies to the person. See\nPersonFilter on when a PersonFilter applies to a person.\nIf not given, the price is valid for all persons."
        }
      },
      "description": "Representation of a price, that is valid for a certain set of persons, i.e. persons matching certain criteria."
    },
    "offerdataPriceSet": {
      "type": "object",
      "properties": {
        "object_price": {
          "type": "number",
          "format": "double",
          "description": "optional - Object price component of the price set (if not given then there must be person prices defined). The\nobject price is valid for the whole object (accommodation/room/board) independent from which kind of persons\nare traveling."
        },
        "person_prices": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/offerdataPersonPrice"
          },
          "description": "optional - List of person prices, that have to be applied (if not given then there must be an object price defined).\nFor a given set of travelling persons with concrete ages, that an offer is searched for, all person prices have to\nbe applied to the set of persons. For each travelling person, all applying person prices have to be summed up to\ncalculate the total amount of person prices. For whether a PersonPrice applies to a person, see PersonPrice."
        }
      },
      "description": "Represents a complex price structure composed out of an object price and person prices used as part of a complete\npricing structure for offers.\n\nA PriceSet should contain at least 1 PersonPrice or an object_price, although both at the same time is possible.\nIn order to calculate the total price of a PriceSet, it is necessary to sum up the object price and all PersonPrices,\nthat apply to the given persons."
    },
    "offerdataRoom_OfferData": {
      "type": "object",
      "properties": {
        "room_identifier": {
          "type": "string",
          "description": "mandatory - Identifier for the room used by the supplier. This identifier references a room\nentity (roomIdentifier) from the BaseDataService. See roomIdentifier of Room.\nThe offer information of this message is valid for the referenced room only."
        },
        "boards": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/offerdataBoard_OfferData"
          },
          "description": "mandatory - List of offer data grouped by boards. boards contains the offer data information for the room. On this\nlevel, the offer data is grouped by boards (see Board in BaseDataService). Each Board_OfferData element will\ncontain all offer data for a single board (in the given room)."
        }
      },
      "description": "Contains offer data associated with one room. The offer data is only valid for the room given by its room_identifier.\nA Room_OfferData entity is to be used in a certain entity (e.g. Accommodation_OfferData) to specify the context of\nthe offer data even further.\n\nKeys: room_identifier\nValues: boards"
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32",
          "description": "The status code, which should be an enum value of\n[google.rpc.Code][google.rpc.Code]."
        },
        "message": {
          "type": "string",
          "description": "A developer-facing error message, which should be in English. Any\nuser-facing error message should be localized and sent in the\n[google.rpc.Status.details][google.rpc.Status.details] field, or localized\nby the client."
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          },
          "description": "A list of messages that carry the error details.  There is a common set of\nmessage types for APIs to use."
        }
      },
      "description": "- Simple to use and understand for most users\n- Flexible enough to meet unexpected needs\n\n# Overview\n\nThe `Status` message contains three pieces of data: error code, error\nmessage, and error details. The error code should be an enum value of\n[google.rpc.Code][google.rpc.Code], but it may accept additional error codes\nif needed.  The error message should be a developer-facing English message\nthat helps developers *understand* and *resolve* the error. If a localized\nuser-facing error message is needed, put the localized message in the error\ndetails or localize it in the client. The optional error details may contain\narbitrary information about the error. There is a predefined set of error\ndetail types in the package `google.rpc` that can be used for common error\nconditions.\n\n# Language mapping\n\nThe `Status` message is the logical representation of the error model, but it\nis not necessarily the actual wire format. When the `Status` message is\nexposed in different client libraries and different wire protocols, it can be\nmapped differently. For example, it will likely be mapped to some exceptions\nin Java, but more likely mapped to some error codes in C.\n\n# Other uses\n\nThe error model and the `Status` message can be used in a variety of\nenvironments, either with or without APIs, to provide a\nconsistent developer experience across different environments.\n\nExample uses of this error model include:\n\n- Partial errors. If a service needs to return partial errors to the client,\n    it may embed the `Status` in the normal response to indicate the partial\n    errors.\n\n- Workflow errors. A typical workflow has multiple steps. Each step may\n    have a `Status` message for error reporting.\n\n- Batch operations. If a client uses batch request and batch response, the\n    `Status` message should be used directly inside batch response, one for\n    each error sub-response.\n\n- Asynchronous operations. If an API call embeds asynchronous operation\n    results in its response, the status of those operations should be\n    represented directly using the `Status` message.\n\n- Logging. If some API errors are stored in logs, the message `Status` could\n    be used directly after any stripping needed for security/privacy reasons.",
      "title": "The `Status` type defines a logical error model that is suitable for\ndifferent programming environments, including REST APIs and RPC APIs. It is\nused by [gRPC](https://github.com/grpc). The error model is designed to be:"
    },
    "runtimeError": {
      "type": "object",
      "properties": {
        "error": {
          "type": "string"
        },
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "typeDate": {
      "type": "object",
      "properties": {
        "year": {
          "type": "integer",
          "format": "int32",
          "description": "Year of date. Must be from 1 to 9999, or 0 if specifying a date without\na year."
        },
        "month": {
          "type": "integer",
          "format": "int32",
          "description": "Month of year. Must be from 1 to 12, or 0 if specifying a year without a\nmonth and day."
        },
        "day": {
          "type": "integer",
          "format": "int32",
          "description": "Day of month. Must be from 1 to 31 and valid for the year and month, or 0\nif specifying a year by itself or a year and month where the day is not\nsignificant."
        }
      },
      "description": "* A full date, with non-zero year, month and day values\n* A month and day value, with a zero year, e.g. an anniversary\n* A year on its own, with zero month and day values\n* A year and month value, with a zero day, e.g. a credit card expiration date\n\nRelated types are [google.type.TimeOfDay][google.type.TimeOfDay] and `google.protobuf.Timestamp`.",
      "title": "Represents a whole or partial calendar date, e.g. a birthday. The time of day\nand time zone are either specified elsewhere or are not significant. The date\nis relative to the Proleptic Gregorian Calendar. This can represent:"
    },
    "v1GlobalType": {
      "type": "object",
      "properties": {
        "GT": {
          "type": "string",
          "description": "mandatory - Global-Type part of the DRV GlobalType."
        },
        "ST": {
          "type": "string",
          "description": "optional - Sub-Type part of the DRV GlobalType."
        },
        "AT": {
          "type": "string",
          "description": "optional - Additional-Type part of the DRV GlobalType."
        },
        "CT": {
          "type": "string",
          "description": "optional - Custom-Type part of the DRV GlobalType."
        }
      },
      "description": "Represents a DRV GlobalType. A DRV GlobalType is a code, that identifies a touristic aspect of an entity like an\naccommodation or a room. For example a DRV GlobalType for a room could identify the room as a room with sea view.\nSee the official DRV GlobalType documentation for further details."
    },
    "v1GroupOfferDataDeliveryPayload": {
      "type": "object",
      "properties": {
        "accommodation_identifier": {
          "type": "string",
          "description": "mandatory - Identifier for the accommodation used by the supplier. This identifier references an accommodation\nentity (supplierAccommodationId) from the BaseDataService. See supplierAccommodationId of Accommodation.\nThe offer information of this message is valid for the referenced accommodation only."
        },
        "rate_identifier": {
          "type": "string",
          "description": "mandatory - Identifier for the rate used by the supplier. This identifier references a rate\nentity (rateIdentifier) from the BaseDataService. See boardIdentifier of Rate.\nThe offer information of this message is valid for the referenced rate only."
        },
        "room_identifier": {
          "type": "string",
          "description": "mandatory - Identifier for the room used by the supplier. This identifier references a room\nentity (roomIdentifier) from the BaseDataService. See roomIdentifier of Room.\nThe offer information of this message is valid for the referenced room only."
        },
        "board_identifier": {
          "type": "string",
          "description": "mandatory - Identifier for the board used by the supplier. This identifier references a board\nentity (boardIdentifier) from the BaseDataService. See boardIdentifier of Board.\nThe offer information of this message is valid for the referenced board only."
        },
        "offer_group": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/offerdataOfferGroup"
          },
          "description": "mandatory - A list of offer groups. Each offer group contains multiple arrival dates and LOSs, to which the same\npricing structure applies, as well as the price information itself (in form of references to the price_sets).\nMultiple offer groups can be given.\n\nA GroupOfferDataDeliveryPayload message for a given accommodation, rate, room and board should contain all offer\ngroups (arrival date + LOS combinations) for the given key, as all other preexisting offer groups will be\nremoved.\n\nSee OfferGroup for more details."
        },
        "price_sets": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/offerdataPriceSet"
          },
          "description": "mandatory - Map of all PriceSets used in this message. The price sets are referenced by the offer groups via a\nunique numeric key (uint32). This key is bound to a specific message and can be arbitrarily chosen. This means\na key for a price set in one message can be different for the same price set in a different message. It does not\nserve as a permanent identifier of a price set.\n\nA price set can be referenced multiple times from offer groups in order to reuse the pricing structure in it. The\npurpose is to optimize the data size by not duplicating the same price data multiple times (e.g. for the same\nprice on consecutive arrival dates or on consecutive days of the stay).\n\nSee PriceSet for more details."
        }
      },
      "description": "Contains offer data for exactly one a group, i.e. a combination of an accommodation, rate, room and board.\n\nKeys: accommodation_identifier, rate_identifier, room_identifier, board_identifier\nValues: offer_group, price_sets\n\nOffer data information is given in offer_group. The prices in offer_group may reference data in price_sets.\nprice_sets is to be used as a lookup table for data in offer_group and is intended for reuse within offer_group and\nacross different offer_group for data size optimization."
    },
    "v1SingleOfferDataDeliveryPayload": {
      "type": "object",
      "properties": {
        "accommodation_identifier": {
          "type": "string",
          "description": "mandatory - Identifier for the accommodation used by the supplier. This identifier references an accommodation\nentity (supplierAccommodationId) from the BaseDataService. See supplierAccommodationId of Accommodation.\nThe offer information of this message is valid for the referenced accommodation only."
        },
        "rate_identifier": {
          "type": "string",
          "description": "mandatory - Identifier for the rate used by the supplier. This identifier references a rate\nentity (rateIdentifier) from the BaseDataService. See rateIdentifier of Rate.\nThe offer information of this message is valid for the referenced rate only."
        },
        "room_identifier": {
          "type": "string",
          "description": "mandatory - Identifier for the room used by the supplier. This identifier references a room\nentity (roomIdentifier) from the BaseDataService. See roomIdentifier of Room.\nThe offer information of this message is valid for the referenced room only."
        },
        "board_identifier": {
          "type": "string",
          "description": "mandatory - Identifier for the board used by the supplier. This identifier references a board\nentity (boardIdentifier) from the BaseDataService. See boardIdentifier of Board.\nThe offer information of this message is valid for the referenced board only."
        },
        "arrivalDate": {
          "$ref": "#/definitions/typeDate",
          "description": "mandatory - The arrival date, that the offer information is valid for. The prices will only be changed for the\ngiven arrival date."
        },
        "los": {
          "type": "integer",
          "format": "int64",
          "description": "mandatory - The lengths of stay (LOSs), that the offer information is valid for. The prices will only be changed for the\ngiven length of stay."
        },
        "offer_value": {
          "$ref": "#/definitions/offerdataOfferValue",
          "description": "mandatory - The offer information including most importantly the price information about the single offer. The\noffer information is valid only for the given key combination of accommodation, rate, room, board, arrival date and\nlength of stay. The offer value contains price information in form of references to price_sets.\n\nSee OfferValue for more details."
        },
        "price_sets": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/offerdataPriceSet"
          },
          "description": "mandatory - Map of all PriceSets used in this message. The price sets are referenced by the offer_value via a\nunique numeric key (uint32). This key is bound to a specific message and can be arbitrarily chosen. This means\na key for a price set in one message can be different for the same price set in a different message. It does not\nserve as a permanent identifier of a price set.\n\nA price set can be referenced multiple times from an offer_value in order to reuse the pricing structure in it. The\npurpose is to optimize the data size by not duplicating the same price data multiple times (e.g. for the same\nprice on consecutive days of the stay).\n\nSee PriceSet for more details."
        }
      },
      "description": "Contains offer data for a single offer, i.e. a combination of an accommodation, rate, room, board, arrival date and\nlength of stay.\n\nKeys: accommodation_identifier, rate_identifier, room_identifier, board_identifier, arrivalDate, offer_value\nValues: offer_value, price_sets\n\nOffer data information is given in offer_value. The prices in offer_value may reference data in price_sets.\nprice_sets is to be used as a lookup table for data in offer_value and is intended for reuse within offer_value for\ndata size optimization."
    }
  }
}
